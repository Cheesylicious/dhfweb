<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Schichtplan - DHF-Planer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* Import einer modernen Schriftart */
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap');

        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            background: #1a1a1a; /* DUNKLER HINTERGRUND (BLEIBT) */
            color: #ffffff;
            overflow-x: hidden;
        }

        /* Das Canvas-Element für die Animation (BLEIBT) */
        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        /* Header (Glas-Effekt) (BLEIBT) */
        header {
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        header h1 { margin: 0; color: #ffffff; font-size: 24px; }
        header nav { display: flex; gap: 20px; align-items: center; }
        header nav a {
            text-decoration: none; color: #bdc3c7; font-weight: 500; font-size: 16px;
            padding: 10px; border-radius: 5px; transition: background-color 0.3s, color 0.3s;
        }
        header nav a.active, header nav a:hover {
            background-color: rgba(255, 255, 255, 0.1); color: #ffffff;
        }
        #user-info { display: flex; align-items: center; gap: 15px; color: #bdc3c7; }
        #logout-btn {
            background: #e74c3c; color: white; padding: 10px 15px; border: none;
            border-radius: 5px; cursor: pointer; font-size: 15px; transition: background-color 0.3s;
        }
        #logout-btn:hover { background: #c0392b; }

        /* Main (Volle Breite) (BLEIBT) */
        main {
            padding: 30px;
            max-width: 100%;
            box-sizing: border-box;
            position: relative;
            z-index: 1;
        }

        /* Card (ZURÜCK ZU WEISS) */
        .card {
            background: #fff;
            color: #333;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            overflow: hidden;
        }

        /* Sub-Nav (Glas-Effekt) (BLEIBT) */
        .sub-nav {
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 0 30px;
            margin-bottom: 30px;
            margin-top: -1px;
            display: flex;
            align-items: center;
            position: relative;
            z-index: 100000;
        }
        .sub-nav a {
            display: inline-block; padding: 15px 20px; text-decoration: none;
            color: #bdc3c7; font-weight: 500; border-bottom: 3px solid transparent;
            transition: color 0.3s;
        }
        .sub-nav a.active, .sub-nav a:hover {
            color: #ffffff;
            border-bottom-color: #3498db;
        }

        /* Dropdown-Menü (KORRIGIERT) */
        .dropdown {
            position: relative;
            display: inline-block;
            z-index: 100001;
        }
        .dropdown .dropbtn {
            font-family: 'Poppins', sans-serif;
            text-decoration: none; color: #bdc3c7; font-weight: 500; font-size: 16px;
            padding: 15px 20px; background: none; border: none; cursor: pointer;
            border-bottom: 3px solid transparent; transition: color 0.3s;
        }
        .dropdown-content {
            display: none;
            position: absolute;
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 200px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 100002;
            border-radius: 5px;
            margin-top: 0px;
            left: 0;
        }
        .dropdown-content a {
            color: #bdc3c7;
            padding: 12px 16px; text-decoration: none; display: block;
            font-size: 15px; border-bottom: none; transition: background-color 0.3s, color 0.3s;
        }
        .dropdown-content a:hover {
            background-color: rgba(255, 255, 255, 0.05);
            color: #ffffff;
        }

        .dropdown:hover .dropdown-content { display: block; }
        .dropdown:hover .dropbtn, .dropbtn.active {
            color: #ffffff;
            border-bottom-color: #3498db;
        }
        .dropdown-content a.active {
            background-color: rgba(52, 152, 219, 0.2);
            font-weight: 600;
            color: #3498db;
        }

        /* --- Grid Styles --- */

        .plan-nav {
            display: flex; justify-content: space-between; align-items: center;
            padding: 20px;
            background-color: #fcfcfc;
            border-bottom: 1px solid #eee;
        }
        .plan-nav h2 { margin: 0; font-size: 22px; color: #333; }
        .plan-nav button {
            padding: 8px 16px; font-size: 15px;
            background: #f0f0f0;
            border: 1px solid #ccc;
            color: #333;
            border-radius: 5px; cursor: pointer; margin-left: 10px;
        }
        .plan-nav button:hover {
            background: #e0e0e0;
        }

        #schichtplan-grid-container { overflow-x: hidden; }
        #schichtplan-grid { display: grid; }

        .grid-header, .grid-cell, .grid-user-name, .grid-user-total, .grid-user-dog {
            padding: 10px;
            border-bottom: 1px solid #eee;
            border-right: 1px solid #eee;
            text-align: center; font-size: 14px; line-height: 1.4;
            overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
            color: #333;
        }

        .grid-header {
            background: #fcfcfc;
            font-weight: 600; position: sticky; top: 0; z-index: 1;
        }

        /* Standard-Wochenende Farbe */
        .grid-header.weekend { background-color: var(--weekend-bg-color, #fff8f8); color: var(--weekend-text-color, #333); }
        .grid-cell.weekend { background-color: var(--weekend-bg-color, #fff8f8); color: var(--weekend-text-color, #333); }

        /* --- NEU: Dynamische Hintergrundfarben für Termine --- */
        .day-color-holiday { background-color: var(--holiday-bg-color, #ffddaa) !important; color: var(--text-color, #333); }
        .day-color-training { background-color: var(--training-bg-color, #daffdb) !important; color: var(--text-color, #333); }
        .day-color-shooting { background-color: var(--shooting-bg-color, #ffb0b0) !important; color: var(--text-color, #333); }
        .grid-header.day-color-holiday { color: var(--text-color, #333); }
        .grid-header.day-color-training { color: var(--text-color, #333); }
        .grid-header.day-color-shooting { color: var(--text-color, #333); }

        .grid-user-name {
            font-weight: 600; text-align: left;
            position: sticky; left: 0;
            background: #fcfcfc;
            z-index: 5;
            border-left: 1px solid #eee;
        }

        .grid-user-dog { font-weight: 500; text-align: left; background: #fcfcfc; color: #555; }
        .grid-header-dog { font-weight: 600; background: #fcfcfc; }
        .grid-user-total { font-weight: 600; background: #f8f9fa; text-align: center; }
        .grid-header-total { font-weight: 600; background: #f8f9fa; }

        /* --- STIL ANPASSUNG (3D-Effekt & Hover) --- */
        .grid-cell {
            cursor: pointer;
            font-weight: 500;
            /* Übergang erweitert */
            transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s;
            /* Leichter 3D-Inset-Schatten */
            box-shadow: inset 0px 1px 3px rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 1;
        }

        body:not(.admin-mode) .grid-cell { cursor: default; }

        /* Hover-Effekt (Zoom & Outset-Schatten) */
        .grid-cell.hovered {
            background-color: #d6eaff !important;
            /* Heller "Outset"-Schatten für den Zoom-Effekt */
            box-shadow: 0px 2px 8px rgba(0, 0, 0, 0.3);
            transform: scale(1.05);
            z-index: 20; /* Zelle überlappt Nachbarn beim Hover */
        }
        /* --- ENDE STIL ANPASSUNG --- */

        body.visitor-mode .grid-cell {
            cursor: default;
        }

        .grid-cell.violation {
            box-shadow: inset 0 0 0 3px #e74c3c !important; /* Roter Rand */
            border: 1px solid #e74c3c !important;
        }

        .plan-legende {
            padding: 20px; display: flex; flex-wrap: wrap; gap: 15px;
            background: #fcfcfc;
            color: #333;
            border-top: 1px solid #eee;
        }
        .plan-legende b { color: #333; }
        .legende-item { display: flex; align-items: center; gap: 5px; }
        .legende-color { width: 15px; height: 15px; border: 1px solid #ccc; border-radius: 3px; }

        .modal {
            display: none; position: fixed; z-index: 100; left: 0; top: 0;
            width: 100%; height: 100%; overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            color: #333;
            margin: 15% auto; padding: 0; border: 1px solid #888;
            width: 80%; max-width: 450px; border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        .modal-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 15px 25px; border-bottom: 1px solid #eee;
        }
        .modal-header h2 { margin: 0; font-size: 18px; color: #333; }
        .close { color: #aaa; font-size: 28px; font-weight: bold; cursor: pointer; }
        .modal-body { padding: 25px; color: #333; }

        #shift-selection { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        #shift-selection button {
            padding: 12px; font-size: 15px; font-weight: 600;
            border: 1px solid #ccc;
            border-radius: 5px; cursor: pointer;
            background-color: #f9f9f9;
            color: #333;
        }
        #shift-selection button:hover {
            border-color: #007bff;
            background-color: #f0f5fa;
        }
        body.visitor-mode #shift-modal {
            display: none !important;
        }
    </style>
</head>
<body>

    <canvas id="particle-canvas"></canvas>

    <header>
        <h1>DHF-Planer</h1>
        <nav>
            <a href="dashboard.html" id="nav-dashboard" style="display: none;">Dashboard</a>
            <a href="users.html" id="nav-users" style="display: none;">Benutzerverwaltung</a>
            <a href="schichtplan.html" class="active">Schichtplan</a>
        </nav>
        <div id="user-info">
            <span id="welcome-user"></span>
            <button id="logout-btn">Abmelden</button>
        </div>
    </header>

    <div class="sub-nav">
        <a href="schichtplan.html" class="active">Schichtplan</a>
        <div class="dropdown" id="settings-dropdown">
            <button class="dropbtn">Einstellungen &raquo;</button>
            <div class="dropdown-content" id="settings-dropdown-content">
                <a href="einstellungen.html" class="admin-only">Mitarbeiter Sortierung</a>
                <a href="schichtarten.html" class="admin-only">Schichtarten</a>
                <a href="shortcuts.html" class="admin-only">Shortcuts</a>
                <a href="feiertage.html" class="admin-only">Feiertage & Sondertermine</a>
                <a href="farbeeinstellungen.html" class="admin-only">Farbeinstellungen</a> </div>
        </div>
    </div>

    <main>
        <div class="card">
            <div class="plan-nav">
                <button id="prev-month-btn">&laquo; Vorheriger</button>
                <h2 id="current-month-label">Lade...</h2>
                <button id="next-month-btn">Nächster &raquo;</button>
            </div>

            <div id="schichtplan-grid-container">
                <div id="schichtplan-grid">
                    </div>
            </div>

            <div class="plan-legende" id="plan-legende">
                </div>
        </div>
    </main>

    <div id="shift-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="shift-modal-title">Schicht auswählen</h2>
                <span class="close" id="close-shift-modal">&times;</span>
            </div>
            <div class="modal-body">
                <p id="shift-modal-info"></p>
                <div id="shift-selection"></div>
            </div>
        </div>
    </div>


    <script>
        // --- START: PARTIKEL-ANIMATION ---
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');
        const nodeColor = '#3498db';
        const lineColor = '#ecf0f1'; // (Angepasst für besseren Kontrast)
        let particlesArray;

        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        setCanvasSize();

        class Particle {
            constructor(x, y, directionX, directionY, size) {
                this.x = x; this.y = y; this.directionX = directionX; this.directionY = directionY; this.size = size;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                ctx.fillStyle = nodeColor;
                ctx.fill();
            }
            update() {
                if (this.x > canvas.width || this.x < 0) { this.directionX = -this.directionX; }
                if (this.y > canvas.height || this.y < 0) { this.directionY = -this.directionY; }
                this.x += this.directionX; this.y += this.directionY;
                this.draw();
            }
        }

        function init() {
            particlesArray = [];
            let numberOfParticles = (canvas.height * canvas.width) / 9000;
            if (numberOfParticles > 100) numberOfParticles = 100;

            for (let i = 0; i < numberOfParticles; i++) {
                let size = (Math.random() * 2) + 1;
                let x = (Math.random() * ((canvas.width - size * 2) - (size * 2)) + size * 2);
                let y = (Math.random() * ((canvas.height - size * 2) - (size * 2)) + size * 2);
                let directionX = (Math.random() * 0.4) - 0.2;
                let directionY = (Math.random() * 0.4) - 0.2;
                particlesArray.push(new Particle(x, y, directionX, directionY, size));
            }
        }

        function connect() {
            let maxDistance = 150;
            ctx.strokeStyle = lineColor;
            for (let a = 0; a < particlesArray.length; a++) {
                for (let b = a; b < particlesArray.length; b++) {
                    let distance = ((particlesArray[a].x - particlesArray[b].x) * (particlesArray[a].x - particlesArray[b].x))
                                 + ((particlesArray[a].y - particlesArray[b].y) * (particlesArray[a].y - particlesArray[b].y));
                    if (distance < (maxDistance * maxDistance)) {
                        let opacity = 1 - (distance / (maxDistance * maxDistance));
                        ctx.globalAlpha = opacity;
                        ctx.beginPath();
                        ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
                        ctx.lineTo(particlesArray[b].x, particlesArray[b].y);
                        ctx.stroke();
                    }
                }
            }
            ctx.globalAlpha = 1.0;
        }

        function animate() {
            requestAnimationFrame(animate);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].update();
            }
            connect();
        }

        window.addEventListener('resize', () => {
            setCanvasSize();
            init();
        });
        init();
        animate();
        // --- ENDE: PARTIKEL-ANIMATION ---
    </script>

    <script>
        // --- Globales Setup (unverändert) ---
        const API_URL = 'http://46.224.63.203:5000';
        const SHORTCUT_STORAGE_KEY = 'dhf_shortcuts';
        const COLOR_STORAGE_KEY = 'dhf_color_settings';
        let user;
        let currentDate = new Date();
        let currentYear = currentDate.getFullYear();
        let currentMonth = currentDate.getMonth() + 1;
        let allUsers = [];
        let allShiftTypes = {};
        let currentShifts = {};
        let currentTotals = {};
        let currentViolations = new Set();
        let currentSpecialDates = {};
        let colorSettings = {};
        let hoveredCellContext = null;

        // --- NEU: Shortcut Map und Rollen-Check Variablen ---
        let shortcutMap = {};
        const defaultShortcuts = { 'T.': 't', 'N.': 'n', '6': '6', 'FREI': 'f', 'X': 'x', 'U': 'u' };
        let isVisitor = false; // <<< NEU
        let isAdmin = false; // <<< NEU (Global definiert)

        const DEFAULT_COLORS = {
            'weekend_bg_color': '#fff8f8',
            'weekend_text_color': '#333333',
            'holiday_bg_color': '#ffddaa',
            'training_bg_color': '#daffdb',
            'shooting_bg_color': '#ffb0b0'
        };


        const gridContainer = document.getElementById('schichtplan-grid-container');
        const grid = document.getElementById('schichtplan-grid');
        const legend = document.getElementById('plan-legende');
        const monthLabel = document.getElementById('current-month-label');
        const prevMonthBtn = document.getElementById('prev-month-btn');
        const nextMonthBtn = document.getElementById('next-month-btn');
        const shiftModal = document.getElementById('shift-modal');
        const shiftModalTitle = document.getElementById('shift-modal-title');
        const shiftModalInfo = document.getElementById('shift-modal-info');
        const shiftSelection = document.getElementById('shift-selection');
        const closeShiftModalBtn = document.getElementById('close-shift-modal');
        let modalContext = { userId: null, dateStr: null };


        // --- Basis-Funktionen (Logout, Auth-Check) ---
        async function logout() {
            try { await apiFetch('/api/logout', 'POST'); }
            catch (e) { console.error(e); }
            finally {
                localStorage.removeItem('dhf_user');
                window.location.href = 'index.html?logout=true';
            }
        }
        try {
            user = JSON.parse(localStorage.getItem('dhf_user'));
            if (!user || !user.vorname || !user.role) { throw new Error("Kein User"); }
            document.getElementById('welcome-user').textContent = `Willkommen, ${user.vorname}!`;

            isAdmin = user.role.name === 'admin';
            isVisitor = user.role.name === 'Besucher';

            const navDashboard = document.getElementById('nav-dashboard');
            const navUsers = document.getElementById('nav-users');
            const settingsDropdown = document.getElementById('settings-dropdown');
            const settingsDropdownContent = document.getElementById('settings-dropdown-content');

            // --- NEUE LOGIK: Navigationsanpassung (KORRIGIERT für Admin-Sichtbarkeit) ---

            // Dashboard Link nur für Admins/User anzeigen
            if (isAdmin || user.role.name === 'user') {
                 navDashboard.style.display = 'block';
            }

            // Benutzerverwaltung Link nur für Admins anzeigen
            if (isAdmin) {
                navUsers.style.display = 'block';
            }

            if (isVisitor) {
                isVisitor = true;
                document.body.classList.add('visitor-mode');
                // Verstecke Dashboard & Benutzerverwaltung in der Hauptnavigation
                navDashboard.style.display = 'none';
                navUsers.style.display = 'none';
            }

            // Verstecke alle admin-only Links für alle, die KEIN Admin sind (User, Besucher)
            if (!isAdmin) {
                document.querySelectorAll('#settings-dropdown-content .admin-only').forEach(el => {
                    el.style.display = 'none';
                });

                // ZUSÄTZLICHER FIX: Wenn der Inhalt des Dropdowns leer ist (nur Admin-Only Links da waren),
                // verstecke das Dropdown selbst (die "Einstellungen" Taste).
                const visibleLinks = settingsDropdownContent.querySelectorAll('a:not([style*="display: none"])');
                if (visibleLinks.length === 0) {
                     settingsDropdown.style.display = 'none';
                }
            } else {
                 // Wenn Admin, füge die Admin-Klasse zum Body hinzu, um den Cursor zu steuern
                 document.body.classList.add('admin-mode');
            }


            // --- ENDE KORRIGIERTE LOGIK ---

        } catch (e) {
            logout();
        }
        document.getElementById('logout-btn').onclick = logout;

        // --- Globale API-Funktion (unverändert) ---
        async function apiFetch(endpoint, method = 'GET', body = null) {
            const options = { method, headers: { 'Content-Type': 'application/json' }, credentials: 'include' };
            if (body) { options.body = JSON.stringify(body); }
            const response = await fetch(API_URL + endpoint, options);
            if (response.status === 401 || response.status === 403) { logout(); throw new Error('Sitzung ungültig oder fehlende Rechte.'); }
            const contentType = response.headers.get("content-type");
            let data;
            if (contentType && contentType.indexOf("application/json") !== -1) { data = await response.json(); } else { data = { message: await response.text() }; }
            if (!response.ok) { throw new Error(data.message || 'API-Fehler'); }
            return data;
        }

        // --- NEU: Laden der Farbeinstellungen aus der DB (Wichtigste Änderung) ---
        async function loadColorSettings() {
             let fetchedColors = DEFAULT_COLORS;

            // Lade Farben aus der Datenbank
            try {
                const data = await apiFetch('/api/settings', 'GET');
                // Überschreibe Defaults nur, wenn Werte in der DB existieren
                for(const key in DEFAULT_COLORS) {
                    if (data[key] !== undefined && data[key] !== null) {
                        fetchedColors[key] = data[key];
                    } else {
                         fetchedColors[key] = DEFAULT_COLORS[key];
                    }
                }
                colorSettings = fetchedColors;
            } catch (error) {
                 console.error("Fehler beim Laden der globalen Einstellungen:", error.message);
                 colorSettings = DEFAULT_COLORS;
            }

            // Setzt CSS-Variablen, um Farben global anwendbar zu machen
            const root = document.documentElement.style;
            for (const key in colorSettings) {
                // Ersetze Unterstrich durch Bindestrich für CSS-Variablen (z.b. weekend_bg_color -> --weekend-bg-color)
                root.setProperty(`--${key.replace(/_/g, '-')}`, colorSettings[key]);
            }
        }
        // --- ENDE NEU: Laden der Farbeinstellungen aus der DB ---


        // --- MODAL-LOGIK (Angepasst) ---
        function closeModal(modalEl) {
            modalEl.style.display = 'none';
        }
        function openShiftModal(userId, dateStr, userName) {
            // Die Prüfung ist jetzt im onclick-Handler, aber wir lassen diese Prüfung als Sicherheitsnetz
            if (!isAdmin) {
                return; // Verbiete das Öffnen des Modals für Nicht-Admins
            }

            const d = new Date(dateStr);
            const dateDisplay = d.toLocaleDateString('de-DE', { weekday: 'long', day: '2-digit', month: '2-digit' });
            modalContext = { userId, dateStr };
            shiftModalTitle.textContent = "Schicht zuweisen";
            shiftModalInfo.textContent = `Für: ${userName} am ${dateDisplay}`;
            shiftModal.style.display = 'block';
        }
        closeShiftModalBtn.onclick = () => closeModal(shiftModal);
        window.onclick = (event) => {
            if (event.target == shiftModal) closeModal(shiftModal);
        }

        // --- NEU: Laden aller Sondertermine ---
        async function loadSpecialDates(year) {
             try {
                // Fügt das Jahr als Filter hinzu
                const dates = await apiFetch(`/api/special_dates?year=${year}`);
                currentSpecialDates = {};
                dates.forEach(d => {
                    if (d.date) {
                        // Key: YYYY-MM-DD
                        currentSpecialDates[d.date] = d.type;
                    }
                });
            } catch (error) {
                 console.error("Fehler beim Laden der Sondertermine:", error.message);
            }
        }
        // --- ENDE NEU: Laden aller Sondertermine ---


        // --- HAUPT-RENDER-LOGIK (Angepasst) ---
        async function renderGrid() {
            monthLabel.textContent = "Lade...";
            grid.innerHTML = '<div style="padding: 20px; text-align: center; color: #333;">Lade Daten...</div>'; // (Textfarbe angepasst)
            try {
                // Lade Daten parallel
                const shiftDataPromise = apiFetch(`/api/shifts?year=${currentYear}&month=${currentMonth}`);
                const userDataPromise = apiFetch('/api/users');
                // Sondertermine werden pro Jahr geladen
                const specialDatesPromise = loadSpecialDates(currentYear);

                const [shiftPayload, userData, specialDatesResult] = await Promise.all([shiftDataPromise, userDataPromise, specialDatesPromise]); // typeDataPromise entfernt

                allUsers = userData;
                // allShiftTypes ist bereits gefüllt durch populateStaticElements

                currentShifts = {};
                shiftPayload.shifts.forEach(s => {
                    const key = `${s.user_id}-${s.date}`;
                    // WICHTIG: Wir müssen die vollen Schichtdaten speichern, nicht nur die ID
                    // (Wir holen sie aus allShiftTypes, das in populateStaticElements geladen wurde)
                    const fullShiftType = allShiftTypes[s.shifttype_id];
                    currentShifts[key] = {
                        ...s,
                        shift_type: fullShiftType // Füge die vollen Schicht-Typ-Daten hinzu
                    };
                });
                currentTotals = shiftPayload.totals;

                // Konflikte speichern
                currentViolations.clear();
                if (shiftPayload.violations) {
                    shiftPayload.violations.forEach(v => {
                        currentViolations.add(`${v[0]}-${v[1]}`);
                    });
                }

                buildGridDOM();
            } catch (error) {
                grid.innerHTML = `<div style="padding: 20px; text-align: center; color: red;">Fehler beim Laden des Plans: ${error.message}</div>`;
            }
        }

        function buildGridDOM() {
            const daysInMonth = new Date(currentYear, currentMonth, 0).getDate();
            const monthName = new Date(currentYear, currentMonth - 1, 1).toLocaleString('de-DE', { month: 'long', year: 'numeric' });
            monthLabel.textContent = monthName;
            grid.style.gridTemplateColumns = `auto auto repeat(${daysInMonth}, 1fr) auto`;
            grid.innerHTML = '';
            const weekdays = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];
            grid.appendChild(document.createElement('div'));
            grid.appendChild(document.createElement('div'));

            // --- HILFSFUNKTION ---
            const renderDayHeader = (day, isWeekend, dateStr) => {
                const eventType = currentSpecialDates[dateStr];

                const headerCell = document.createElement('div');
                let headerClasses = 'grid-header';
                let cellColor = ''; // (Wird nicht mehr für Wochenende/Events genutzt)
                let textColor = '#333';

                if (eventType) {
                    headerClasses += ` day-color-${eventType}`;
                } else if (isWeekend) {
                    headerClasses += ' weekend'; // (CSS-Variable wird im Stil angewendet)
                } else {
                    cellColor = '#fcfcfc'; // Default normaler Tag
                }

                headerCell.className = headerClasses;
                if (cellColor) headerCell.style.backgroundColor = cellColor;
                if (textColor && !isWeekend && !eventType) headerCell.style.color = textColor;

                return headerCell;
            };

            // --- Erzeugung der Header-Zeilen 1 (Wochentage) ---
            for (let day = 1; day <= daysInMonth; day++) {
                const d = new Date(currentYear, currentMonth - 1, day);
                const dayName = weekdays[d.getDay()];
                const isWeekend = d.getDay() === 0 || d.getDay() === 6;

                const dateStr = `${currentYear}-${String(currentMonth).padStart(2, '0')}-${String(day).padStart(2, '0')}`;

                const headerCell = renderDayHeader(day, isWeekend, dateStr);
                headerCell.textContent = dayName;
                grid.appendChild(headerCell);
            }

            grid.appendChild(document.createElement('div'));
            grid.appendChild(document.createElement('div'));
            const dogHeader = document.createElement('div');
            dogHeader.className = 'grid-header-dog';
            dogHeader.textContent = 'Diensthund';
            grid.appendChild(dogHeader);

            // --- Erzeugung der Header-Zeilen 2 (Tage des Monats) ---
            for (let day = 1; day <= daysInMonth; day++) {
                const d = new Date(currentYear, currentMonth - 1, day);
                const isWeekend = d.getDay() === 0 || d.getDay() === 6;

                const dateStr = `${currentYear}-${String(currentMonth).padStart(2, '0')}-${String(day).padStart(2, '0')}`;

                const headerCell = renderDayHeader(day, isWeekend, dateStr);
                headerCell.textContent = day;
                grid.appendChild(headerCell);
            }

            const totalHeader = document.createElement('div');
            totalHeader.className = 'grid-header-total';
            totalHeader.textContent = 'Std.';
            grid.appendChild(totalHeader);

            const visibleUsers = allUsers.filter(user => user.shift_plan_visible === true);

            // --- Erzeugung der Benutzer-Zellen ---
            visibleUsers.forEach(user => {
                const nameCell = document.createElement('div');
                nameCell.className = 'grid-user-name';
                nameCell.textContent = `${user.vorname} ${user.name}`;
                grid.appendChild(nameCell);
                const dogCell = document.createElement('div');
                dogCell.className = 'grid-user-dog';
                dogCell.textContent = user.diensthund || '---';
                grid.appendChild(dogCell);

                for (let day = 1; day <= daysInMonth; day++) {
                    const d = new Date(currentYear, currentMonth - 1, day);
                    const isWeekend = d.getDay() === 0 || d.getDay() === 6;

                    const year = d.getFullYear();
                    const month = String(d.getMonth() + 1).padStart(2, '0');
                    const dayOfMonth = String(d.getDate()).padStart(2, '0');
                    const dateStr = `${year}-${month}-${dayOfMonth}`;

                    const key = `${user.id}-${dateStr}`;
                    const violationKey = `${user.id}-${day}`;
                    const eventType = currentSpecialDates[dateStr];

                    const shift = currentShifts[key];
                    // KORREKTUR: shift_type ist jetzt ein volles Objekt
                    const shiftType = shift ? shift.shift_type : null;
                    const cell = document.createElement('div');

                    // --- KORRIGIERTE LOGIK FÜR FARBEN & "---" ---
                    let cellClasses = 'grid-cell';
                    let cellColor = null; // (Standard: null, damit CSS-Klassen greifen)
                    let textColor = null; // (Standard: null, damit CSS-Klassen greifen)

                    if (currentViolations.has(violationKey)) {
                         cellClasses += ' violation';
                    }

                    const dayHasSpecialBg = eventType || isWeekend;

                    if (shiftType) {
                        cell.textContent = shiftType.abbreviation;

                        // Prüfe die neue Einstellung
                        if (shiftType.prioritize_background && dayHasSpecialBg) {
                            // PRIORISIERUNG: Nutze Tagesfarbe (Klasse)
                            if (eventType) {
                                cellClasses += ` day-color-${eventType}`;
                            } else if (isWeekend) {
                                cellClasses += ' weekend';
                            }
                            // Textfarbe wird von der Klasse gesteuert
                        } else {
                            // STANDARD: Nutze Schichtfarbe (Inline Style)
                            cellColor = shiftType.color;
                            textColor = isColorDark(shiftType.color) ? 'white' : 'black';
                        }

                    } else {
                        // KEINE SCHICHT
                        cell.textContent = ''; // KORREKTUR: "---" entfernt

                        if (eventType) {
                             cellClasses += ` day-color-${eventType}`;
                        } else if (isWeekend) {
                            cellClasses += ' weekend';
                        }
                        // Textfarbe wird von der Klasse gesteuert
                    }
                    // --- ENDE KORRIGIERTE LOGIK ---

                    cell.className = cellClasses;
                    // Wende Inline-Stile nur an, wenn sie explizit gesetzt wurden (d.h. Schichtfarbe hat Prio)
                    if (cellColor) {
                        cell.style.backgroundColor = cellColor;
                    }
                    if (textColor) {
                        cell.style.color = textColor;
                    }

                    cell.dataset.key = key;

                    if (isAdmin) {
                        cell.onclick = () => {
                            openShiftModal(user.id, dateStr, `${user.vorname} ${user.name}`);
                        };
                        cell.onmouseenter = () => {
                            cell.classList.add('hovered');
                            hoveredCellContext = {
                                userId: user.id, dateStr: dateStr,
                                userName: `${user.vorname} ${user.name}`,
                                cellElement: cell
                            };
                        };
                        cell.onmouseleave = () => {
                            cell.classList.remove('hovered');
                            hoveredCellContext = null;
                        };
                    } else {
                        cell.style.cursor = 'default';
                    }
                    grid.appendChild(cell);
                }
                const totalCell = document.createElement('div');
                totalCell.className = 'grid-user-total';
                totalCell.id = `total-hours-${user.id}`;
                const userTotalHours = currentTotals[user.id] || 0.0;
                totalCell.textContent = userTotalHours.toFixed(1);
                grid.appendChild(totalCell);
            });
        }

        // --- NEU: Helligkeitsprüfung für Textfarbe (innovativ) ---
        function isColorDark(hexColor) {
            if (!hexColor) return false; // Fallback
            // Konvertiert RGB in Dezimal
            const hex = hexColor.replace('#', '');
            // (Robustheits-Check für ungültige Farben)
            if (hex.length !== 6) return false;
            try {
                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);
                // Berechne Luminanz
                const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                return luminance < 0.5;
            } catch (e) {
                return false;
            }
        }
        // --- ENDE NEU: Helligkeitsprüfung ---


        // (populateStaticElements - angepasst für Modal/Legende)
        async function populateStaticElements() {
            // Laden der Schichtarten
            if (Object.keys(allShiftTypes).length === 0) {
                const typeData = await apiFetch('/api/shifttypes');
                // KORREKTUR: Sicherstellen, dass alle Daten (inkl. prioritize_background) hier gespeichert werden
                typeData.forEach(st => allShiftTypes[st.id] = st);
            }

            legend.innerHTML = '<b>Legende:</b>';
            shiftSelection.innerHTML = '';

            Object.values(allShiftTypes).forEach(st => {
                const item = document.createElement('div');
                item.className = 'legende-item';

                // NEU: Fügt Indikator hinzu, wenn Hintergrund priorisiert wird
                const priorityIndicator = st.prioritize_background ? ' (Hintergrund prior.)' : '';

                item.innerHTML = `<div class="legende-color" style="background-color: ${st.color};"></div> ${st.abbreviation} (${st.name}${priorityIndicator})`;
                legend.appendChild(item);

                // Füge nur Buttons hinzu, wenn es kein Besucher ist
                if (!isVisitor) {
                    const btn = document.createElement('button');
                    btn.textContent = `${st.abbreviation} (${st.name})`;
                    btn.style.backgroundColor = st.color;
                    // Wenn die Hintergrundfarbe dunkel ist, Text auf Weiß stellen
                    if (isColorDark(st.color)) {
                        btn.style.color = 'white';
                    } else {
                        btn.style.color = 'black';
                    }
                    btn.onclick = () => saveShift(st.id, modalContext.userId, modalContext.dateStr);
                    shiftSelection.appendChild(btn);
                }
            });
        }

        // --- DATEN SPEICHERN (Angepasst) ---
        async function saveShift(shifttypeId, userId, dateStr) {
            // <<< WICHTIG: Erneute Backend-Sicherheitsprüfung
            if (!isAdmin) { // Nur Admins dürfen speichern
                console.error("Nicht-Admins dürfen keine Schichten speichern.");
                return;
            }
            // >>>

            if (!userId || !dateStr) return;
            const key = `${userId}-${dateStr}`;
            const cell = findCellByKey(key);
            try {
                if(cell) cell.textContent = '...';
                const savedData = await apiFetch('/api/shifts', 'POST', {
                    user_id: userId,
                    date: dateStr,
                    shifttype_id: shifttypeId
                });
                closeModal(shiftModal);

                // 1. Schicht-Daten im Frontend-Cache aktualisieren
                // (Hole die vollen Schichtdaten aus dem Cache)
                const shiftType = allShiftTypes[savedData.shifttype_id];
                const shiftWasDeleted = savedData.message && (savedData.message.includes("gelöscht") || savedData.message.includes("bereits Frei"));

                if (shiftWasDeleted) {
                    currentShifts[key] = null;
                } else if (shiftType) {
                    // KORREKTUR: Speichere das volle Schicht-Objekt, damit buildGridDOM es lesen kann
                    currentShifts[key] = {
                        ...savedData,
                        shift_type: shiftType
                    };
                } else {
                     currentShifts[key] = savedData; // Fallback
                }

                // 2. Konflikt-Set komplett neu setzen
                currentViolations.clear();
                if (savedData.violations) {
                    // Konvertiere Liste von [user_id, day] zu Set von "user_id-day"
                    savedData.violations.forEach(v => {
                        currentViolations.add(`${v[0]}-${v[1]}`);
                    });
                }

                // 3. Grid neu zeichnen, um alle Konflikt-Ränder und Farben korrekt darzustellen
                buildGridDOM();

                // 4. Stunden aktualisieren (unverändert)
                const totalCell = document.getElementById(`total-hours-${userId}`);
                if (totalCell) {
                    totalCell.textContent = (savedData.new_total_hours || 0.0).toFixed(1);
                }

            } catch (error) {
                if (cell) cell.textContent = 'Fehler!';
                alert(`Fehler beim Speichern: ${error.message}`);
                if (shiftModal.style.display === 'block') {
                    shiftModalInfo.textContent = `Fehler: ${error.message}`;
                }
            }
        }

        // (findCellByKey - unverändert)
        function findCellByKey(key) {
            return grid.querySelector(`[data-key="${key}"]`);
        }

        // --- NAVIGATIONS-EVENTS (unverändert) ---
        prevMonthBtn.onclick = () => {
            currentMonth--;
            if (currentMonth < 1) { currentMonth = 12; currentYear--; }
            // Lade Farben und rendere
            loadColorSettings();
            // KORREKTUR: Muss Schichtarten neu laden, falls sie sich geändert haben
            // (Sicherer, aber langsamer)
            // Besser: Nur renderGrid() aufrufen.
            renderGrid();
        };
        nextMonthBtn.onclick = () => {
            currentMonth++;
            if (currentMonth > 12) { currentMonth = 1; currentYear++; }
            // Lade Farben und rendere
            loadColorSettings();
            renderGrid();
        };

        // --- NEU: Shortcut Ladefunktion (FINAL FIXED) ---
        function loadShortcuts() {
            let savedShortcuts = {};
            try {
                // 1. Gespeicherte, benutzerdefinierte Shortcuts laden
                const data = localStorage.getItem(SHORTCUT_STORAGE_KEY);
                if (data) {
                    savedShortcuts = JSON.parse(data);
                }
            } catch (e) {
                console.error("Fehler beim Laden der Shortcuts aus localStorage, verwende Standards.", e);
            }

            const mergedShortcuts = {};
            const allAbbrevs = Object.values(allShiftTypes).map(st => st.abbreviation);

            // 2. Gehe alle in der DB existierenden Abkürzungen durch
            allAbbrevs.forEach(abbrev => {
                // Priorität: 1. Gespeicherte (LocalStorage) > 2. Standard (hardcoded)
                const key = savedShortcuts[abbrev] || defaultShortcuts[abbrev];

                // Füge nur hinzu, wenn ein Key definiert ist (um leere Einträge zu vermeiden)
                if (key) {
                    mergedShortcuts[abbrev] = key;
                }
            });

            // Dreht die Map um: { 't': 'T.' }
            // Wir mappen den Tastendruck (key) auf die Schicht-Abkürzung (abbrev)
            shortcutMap = Object.fromEntries(
                Object.entries(mergedShortcuts).map(([abbrev, key]) => [key, abbrev])
            );
        }

        // --- KEYBOARD SHORTCUT LISTENER (Angepasst) ---
        window.addEventListener('keydown', async (event) => {
            // FIX: Verbiete Shortcuts für alle, die NICHT Admin sind
            if (!isAdmin) return;

            if (shiftModal.style.display === 'block') return;
            if (!hoveredCellContext || !hoveredCellContext.userId) return;

            const key = event.key.toLowerCase();

            // NEU: Verwendet die dynamische shortcutMap
            const abbrev = shortcutMap[key]; // z.b. shortcutMap['t'] -> 'T.'

            if (abbrev !== undefined) {
                event.preventDefault();

                // Findet die Schichtart anhand der Abkürzung (z.b. 'T.')
                const shiftType = Object.values(allShiftTypes).find(st => st.abbreviation === abbrev);

                if (shiftType) {
                    await saveShift(shiftType.id, hoveredCellContext.userId, hoveredCellContext.dateStr);
                } else {
                    // Dieser Fall sollte NUR auftreten, wenn eine Abkürzung im localStorage gespeichert ist,
                    // die aber nicht mehr in der DB existiert.
                    console.warn(`Shortcut "${key}" (Abk.: "${abbrev}") nicht in allShiftTypes gefunden.`);
                }
            }
        });

        // --- Initialisierung (FIX: Load Shortcuts früher) ---
        async function initialize() {
            // MUSS zuerst geladen werden, damit CSS-Variablen für das erste Rendern gesetzt sind
            await loadColorSettings();

            // 1. Schichtarten laden & statische Elemente befüllen
            // WICHTIG: allShiftTypes wird hier gefüllt und ist für loadShortcuts UND renderGrid nötig!
            await populateStaticElements();

            // 2. Shortcuts laden (Karte ist jetzt bereit für Keydown-Events)
            loadShortcuts();

            // 3. (renderGrid lädt den Rest und rendert)
            await renderGrid();
        }

        initialize();

    </script>
</body>
</html>